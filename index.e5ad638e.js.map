{"mappings":"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","sources":["src/core/shared.js","src/framework/Frame.js","src/core/Engine.js","src/framework/Color.js","src/snake/scoreManager.js","src/snake/htmlManager.js","src/framework/Entity.js","src/framework/EntityController.js","src/framework/CollidableEntity.js","src/snake/util.js","src/snake/SnakeEntityController.js","src/snake/PowersEntityController.js","src/snake/RootEntityController.js","src/main.js"],"sourcesContent":["export const shared = {\n  engine: null,\n  renderingContext: null,\n};\n","export class Frame {\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  get param() {\n    return [this.x, this.y, this.width, this.height];\n  }\n\n  get isEmpty() {\n    return this.width === 0 || this.height === 0;\n  }\n}\n\nFrame.prototype.toString = function () {\n  return `{x: ${this.x}, y: ${this.y}, width: ${this.width}, height: ${this.height}}`;\n};\n\n// 🚧 DO NOT USE: SCALABLE COLLISION DETECTION LOGIC IS IN PROGRESS 🚧\nFrame.prototype._IN_DEVELOPMENT_canCollideWith = function (withFrame) {\n  const extrapolateToPoints = (f) => [f.x, f.y, f.x + f.width, f.y + f.height];\n  const [thisX1, thisY1, thisX2, thisY2] = extrapolateToPoints(this);\n  const [withX1, withY1, withX2, withY2] = extrapolateToPoints(withFrame);\n\n  const isPointInsideThis = (x, y) =>\n    x >= thisX1 && x < thisX2 && y >= thisY1 && y < thisY2;\n\n  return (\n    isPointInsideThis(withX1, withY1) ||\n    isPointInsideThis(withX1, withY2) ||\n    isPointInsideThis(withX2, withY1) ||\n    isPointInsideThis(withX2, withY2)\n  );\n};\n\nexport const makeFrame = (x, y, width, height) =>\n  new Frame(x, y, width, height);\n\nexport const makeZeroFrame = () => makeFrame(0, 0, 0, 0);\n\n/**\n * 🚧 DO NOT USE: SCALABLE COLLISION DETECTION LOGIC IS IN PROGRESS 🚧\n * Returns true if given frame collides with each other\n * TODO: Implement scalable collision detection\n * @param {Frame} aFrame\n * @param {Frame} bFrame\n * @returns boolean\n */\nexport function detectScalableCollision(aFrame, bFrame) {\n  // This simple collision detection is working cause in snake game all entities have similar width and height\n  const isOriginEqual = aFrame.x === bFrame.x && aFrame.y === bFrame.y;\n  const isSizeEqual =\n    aFrame.width === bFrame.width && aFrame.height === bFrame.height;\n  return isOriginEqual && isSizeEqual;\n}\n\n/**\n * Returns true if given frame collides with each other\n * TODO: Implement scalable collision detection\n * @param {Frame} aFrame\n * @param {Frame} bFrame\n * @returns boolean\n */\nexport function detectCollision(aFrame, bFrame) {\n  // This simple collision detection is working cause in snake game all entities have similar width and height\n  const isOriginEqual = aFrame.x === bFrame.x && aFrame.y === bFrame.y;\n  const isSizeEqual =\n    aFrame.width === bFrame.width && aFrame.height === bFrame.height;\n  return isOriginEqual && isSizeEqual;\n}\n","import { shared } from './shared';\nimport { detectCollision, Frame, makeFrame } from '../framework/Frame';\n\nexport class Engine {\n  constructor(RootEntityControllerClass, canvasID, fps) {\n    shared.engine = this;\n    shared.renderingContext = document\n      .getElementById(canvasID)\n      .getContext('2d');\n\n    this.RootEntityControllerClass = RootEntityControllerClass;\n    this.fps = fps;\n\n    this._addEventListeners();\n  }\n\n  /** whether the engine should pause in next update */\n  shouldPause = false;\n\n  /** Whether the engine is paused */\n  paused = false;\n}\n\nEngine.prototype.initialize = function () {\n  this.rootEntityController = new this.RootEntityControllerClass();\n\n  this.paused = true; // Initially engine is in paused state\n  this.didGameOver = false;\n  this.fpsInterval = 1000 / this.fps;\n  this.then = Date.now();\n\n  // Load the entities in respective entity controllers\n  walkEntityControllerHierarchy(this.rootEntityController, (ec) => {\n    ec.loadEntity();\n  });\n\n  // Initial draw, next draw will be after update\n  this.rootEntityController.entity.draw();\n};\n\nEngine.prototype.pause = function () {\n  console.info('[engine] paused'); // Will pause after one loop\n  this.shouldPause = true;\n};\n\nEngine.prototype.play = function () {\n  if (this.didGameOver) {\n    this.reset();\n  } else {\n    console.info('[engine] started');\n    this.paused = false;\n\n    // Trigger loop\n    window.requestAnimationFrame(() => this.loop());\n  }\n};\n\nEngine.prototype.gameOver = function () {\n  console.info('[engine] game over');\n  this.didGameOver = true;\n};\n\nEngine.prototype.reset = function () {\n  console.assert(this.paused, 'Engine should be paused first to rest');\n  console.info('[engine] reset');\n\n  // Re-initialize engine\n  this.initialize();\n\n  // Start the game immediately\n  this.play();\n};\n\nEngine.prototype.loop = function () {\n  if (!this.paused) {\n    window.requestAnimationFrame(() => this.loop());\n  }\n\n  const now = Date.now();\n  const elapsed = now - this.then;\n  if (elapsed > this.fpsInterval) {\n    this.then = now - (elapsed % this.fpsInterval);\n\n    // Game Tick\n    this._tick();\n  }\n};\n\nEngine.prototype.getWorldFrame = function () {\n  // We are not storing this values since they can be changed at runtime\n  const canvasEl = shared.renderingContext.canvas;\n  return makeFrame(0, 0, canvasEl.width, canvasEl.height);\n};\n\nEngine.prototype._tick = function () {\n  // Do not draw when engine is planning to pause\n  if (this.shouldPause) {\n    this.shouldPause = false;\n    this.paused = true;\n\n    this.rootEntityController.update();\n  }\n\n  // Clear the whole canvas first\n  shared.renderingContext.clearRect(...this.getWorldFrame().param);\n\n  // Update the Entity Controller\n  this.rootEntityController.update();\n\n  // Draw the root Entity\n  this.rootEntityController.entity.draw();\n\n  // Detect collision and forward if any\n  // This is a costly operation which involves risky recursive code\n  this._detectCollisionAndForward();\n};\n\nEngine.prototype._addEventListeners = function () {\n  // Add key press event listener\n  document.addEventListener('keydown', (event) => {\n    this._didKeyDown(event);\n  });\n};\n\nEngine.prototype._didKeyDown = function ({ key }) {\n  // TODO: Higher level play-pause\n  if (key === ' ') {\n    this.paused ? this.play() : this.pause();\n  }\n\n  if (!this.paused) {\n    this.rootEntityController.didKeyDown(key);\n  }\n};\n\n/**\n * Returns true if target frame will collide with any of the entities in hierarchy\n * @param {Frame} targetFrame\n * @returns boolean\n */\nEngine.prototype.willAnyEntityCollideWith = function (targetFrame) {\n  // TODO: Can be improved by returning early if we found any collisions\n  return this._collidingEntitiesWithFrame(targetFrame).size > 0;\n};\n\nEngine.prototype._collidingEntitiesWithFrame = function (targetFrame) {\n  const collidingEntities = new Set();\n  walkEntityHierarchy(this.rootEntityController.entity, (entity) => {\n    if (\n      entity.collidable &&\n      !entity.frame.isEmpty &&\n      detectCollision(targetFrame, entity.frame)\n    ) {\n      collidingEntities.add(entity);\n    }\n  });\n\n  return collidingEntities;\n};\n\nEngine.prototype._detectCollisionAndForward = function () {\n  // TODO: Faster collision detection and forward with cached flat maps ??\n  walkEntityHierarchy(this.rootEntityController.entity, (entity) => {\n    if (entity.collidable && !entity.frame.isEmpty) {\n      const collidingEntities = this._collidingEntitiesWithFrame(entity.frame);\n      collidingEntities.delete(entity);\n\n      collidingEntities.forEach((collidingEntity) => {\n        console.info(`[collision] between ${entity} and ${collidingEntity}`);\n\n        entity.didCollideWith(collidingEntity);\n      });\n    }\n  });\n};\n\nfunction walkEntityControllerHierarchy(entityController, fn) {\n  const recursivelyWalk = (currEntityController) => {\n    fn(currEntityController);\n\n    currEntityController.childEntityControllers.forEach((child) => {\n      recursivelyWalk(child);\n    });\n  };\n\n  return recursivelyWalk(entityController);\n}\n\nfunction walkEntityHierarchy(entity, fn) {\n  const recursiveWalk = (currEntity) => {\n    fn(currEntity);\n\n    currEntity.subEntities.forEach((subEntity) => {\n      recursiveWalk(subEntity);\n    });\n  };\n\n  return recursiveWalk(entity);\n}\n","export const Color = {\n  clear: 'clear',\n  black: 'black',\n  white: 'white',\n  yellow: 'yellow',\n  red: 'red',\n  grey: 'grey',\n\n  color: (r, g, b) => `rgb(${r}, ${g}, ${b})`,\n};\n","class ScoreManager {\n  currentScore = 0;\n  highestScore = 0;\n}\n\nScoreManager.prototype.incrementCurrentScore = function () {\n  this.currentScore += 1;\n\n  this.updateHighestScore();\n};\n\nScoreManager.prototype.resetCurrentScore = function () {\n  this.currentScore = 0;\n};\n\nScoreManager.prototype.updateHighestScore = function () {\n  this.highestScore = Math.max(this.currentScore, this.highestScore);\n};\n\nexport const scoreManager = new ScoreManager();\n","import { shared } from '../core/shared';\nimport { scoreManager } from './scoreManager';\nimport { Color } from '../framework/Color';\n\nclass HTMLManager {}\n\nHTMLManager.prototype.initialize = function () {\n  this.gameScoreEl = document.getElementById('game-dash-score');\n\n  this.gameHighScoreEl = document.getElementById('game-dash-highscore');\n\n  this.gameStatusEl = {\n    paused: document.getElementById('game-dash-status-paused'),\n    gameOver: document.getElementById('game-dash-status-game-over'),\n  };\n\n  this.gameInstructionsEl = {\n    startGame: document.getElementById('game-dash-instructions-start-game'),\n    playGame: document.getElementById('game-dash-instructions-play-game'),\n  };\n\n  // Color the html components in initializer\n  document.getElementsByTagName('body')[0].style.backgroundColor =\n    Color.bgColor;\n  const addFontColor = (el) => {\n    el.style.color = Color.fontColor;\n  };\n  Array.prototype.forEach.call(\n    document.getElementsByClassName('font'),\n    addFontColor\n  );\n};\n\nHTMLManager.prototype.update = function () {\n  this.gameScoreEl.innerHTML = scoreManager.currentScore;\n  this.gameHighScoreEl.innerHTML = `hi ${scoreManager.highestScore}`;\n\n  this.gameStatusEl.paused.hidden = true;\n  this.gameStatusEl.gameOver.hidden = true;\n  this.gameInstructionsEl.startGame.hidden = true;\n  this.gameInstructionsEl.playGame.hidden = true;\n\n  if (shared.engine.didGameOver) {\n    this.gameStatusEl.gameOver.hidden = false;\n    this.gameInstructionsEl.startGame.hidden = false;\n  } else if (shared.engine.paused) {\n    this.gameStatusEl.paused.hidden = false;\n    this.gameInstructionsEl.startGame.hidden = false;\n  } else {\n    this.gameInstructionsEl.playGame.hidden = false;\n  }\n};\n\nexport const htmlManager = new HTMLManager();\n","import { makeZeroFrame } from './Frame';\nimport { shared } from '../core/shared';\nimport { Color } from './Color';\n\nconst UNKNOWN_ENTITY_TYPE = 'UNKNOWN_ENTITY_TYPE';\n\nexport class Entity {\n  /** Whether this entity should be collidable or not. */\n  collidable = false;\n\n  /** Type of the entity */\n  type = UNKNOWN_ENTITY_TYPE;\n\n  /** Sub entities present under this entity */\n  subEntities = [];\n\n  /** Background color */\n  bgColor = Color.clear;\n\n  constructor(frame = makeZeroFrame()) {\n    this.frame = frame;\n  }\n}\n\nEntity.prototype.toString = function () {\n  return `[${this.type} ${this.frame}]`;\n};\n\nEntity.prototype.draw = function () {\n  if (!this.frame.isEmpty && this.bgColor !== Color.clear) {\n    shared.renderingContext.fillStyle = this.bgColor;\n    shared.renderingContext.fillRect(...this.frame.param);\n  }\n\n  // Draw sub-entities\n  this.subEntities.forEach((e) => e.draw());\n};\n\nEntity.prototype.didCollideWith = function (otherEntity) {\n  console.error('Collision detection should be overridden by subclass');\n};\n","import { Entity } from './Entity';\n\nexport class EntityController {\n  /** Root entity directly associated with this Entity Controller */\n  entity = new Entity();\n\n  /** Child entity controller in the hierarchy */\n  childEntityControllers = [];\n}\n\n/**\n * Override this to load the entity.\n * Default implementation is a no-op.\n */\nEntityController.prototype.loadEntity = function () {};\n\nEntityController.prototype.didKeyDown = function (key) {\n  console.error('Override this function in root entity controller');\n};\n\nEntityController.prototype.update = function () {\n  this.childEntityControllers.forEach((ec) => ec.update());\n};\n","import { Entity } from './Entity';\n\nexport class CollidableEntity extends Entity {\n  collidable = true;\n\n  /** callback when collision is detected for the entity. */\n  collisionCallback = null;\n}\n\nCollidableEntity.prototype.didCollideWith = function (otherEntity) {\n  if (this.collisionCallback) {\n    this.collisionCallback(otherEntity);\n  }\n};\n","export const Direction = {\n  left: '←',\n  up: '↑',\n  right: '→',\n  down: '↓',\n  none: 'none',\n};\n\nexport const mod = (left, right) => {\n  'use strict';\n  return ((left % right) + right) % right;\n};\n\nexport const randomNumber = (min, max, unit = 1) => {\n  min /= unit;\n  max /= unit;\n\n  return (Math.floor(Math.random() * (max - min + 1)) + min) * unit;\n};\n","import { makeFrame } from '../framework/Frame';\nimport { EntityController } from '../framework/EntityController';\nimport { Direction, mod } from './util';\nimport { shared } from '../core/shared';\nimport { POWER_ENTITY_TYPE } from './PowersEntityController';\nimport { CollidableEntity } from '../framework/CollidableEntity';\nimport { Color } from '../framework/Color';\nimport { scoreManager } from './scoreManager';\n\nexport const SNAKE_ENTITY_TYPE = 'SNAKE_ENTITY_TYPE';\nconst SNAKE_ENTITY_SIZE = 10;\n\nclass SnakeEntity extends CollidableEntity {\n  type = SNAKE_ENTITY_TYPE;\n  bgColor = Color.snakeColor;\n  constructor(x, y) {\n    super(makeFrame(x, y, SNAKE_ENTITY_SIZE, SNAKE_ENTITY_SIZE));\n  }\n}\n\nexport class SnakeEntityController extends EntityController {\n  direction = Direction.none;\n  powerUp = false;\n}\n\nSnakeEntityController.prototype.loadEntity = function () {\n  this.snakeEntities = [this._createSnakeEntity(0, 0)];\n  this.snakeHeadEntity = this.snakeEntities[0];\n  this.entity.subEntities = this.snakeEntities;\n};\n\nSnakeEntityController.prototype.update = function () {\n  if (this.direction === Direction.none) {\n    return;\n  }\n\n  let deltaInXYForDirection = {};\n  deltaInXYForDirection[Direction.up] = [0, -SNAKE_ENTITY_SIZE];\n  deltaInXYForDirection[Direction.left] = [-SNAKE_ENTITY_SIZE, 0];\n  deltaInXYForDirection[Direction.down] = [0, SNAKE_ENTITY_SIZE];\n  deltaInXYForDirection[Direction.right] = [SNAKE_ENTITY_SIZE, 0];\n\n  const worldFrame = shared.engine.getWorldFrame();\n  const [dx, dy] = deltaInXYForDirection[this.direction];\n  const newHeadX = mod(this.snakeHeadEntity.frame.x + dx, worldFrame.width);\n  const newHeadY = mod(this.snakeHeadEntity.frame.y + dy, worldFrame.height);\n\n  if (this.powerUp) {\n    const newSnakeHeadEntity = this._createSnakeEntity(newHeadX, newHeadY);\n    this.snakeEntities.push(newSnakeHeadEntity);\n    this.snakeHeadEntity = newSnakeHeadEntity;\n\n    this.powerUp = false;\n  } else {\n    const snakeHeadEntity = this.snakeEntities.shift();\n    snakeHeadEntity.frame.x = newHeadX;\n    snakeHeadEntity.frame.y = newHeadY;\n    this.snakeEntities.push(snakeHeadEntity);\n    this.snakeHeadEntity = snakeHeadEntity;\n  }\n};\n\nSnakeEntityController.prototype.didKeyDown = function (key) {\n  const changeDirectionForKeyCallbacks = {\n    w: () =>\n      (this.direction =\n        this.direction === Direction.down ? Direction.down : Direction.up),\n    a: () =>\n      (this.direction =\n        this.direction === Direction.right ? Direction.right : Direction.left),\n    s: () =>\n      (this.direction =\n        this.direction === Direction.up ? Direction.up : Direction.down),\n    d: () =>\n      (this.direction =\n        this.direction === Direction.left ? Direction.left : Direction.right),\n  };\n\n  if (key in changeDirectionForKeyCallbacks) {\n    changeDirectionForKeyCallbacks[key]();\n    console.info(`[snake] direction changed to ${this.direction}`);\n  }\n};\n\nSnakeEntityController.prototype._createSnakeEntity = function (x, y) {\n  const snakeEntity = new SnakeEntity(x, y);\n  snakeEntity.collisionCallback = (otherEntity) => {\n    this._snakeEntityDidCollide(otherEntity);\n  };\n  return snakeEntity;\n};\n\nSnakeEntityController.prototype._snakeEntityDidCollide = function (entity) {\n  if (entity.type === POWER_ENTITY_TYPE) {\n    this.powerUp = true; // Power up in next update\n    scoreManager.incrementCurrentScore();\n  } else if (entity.type === SNAKE_ENTITY_TYPE) {\n    shared.engine.pause();\n    shared.engine.gameOver();\n    scoreManager.resetCurrentScore();\n  }\n};\n","import { shared } from '../core/shared';\nimport { CollidableEntity } from '../framework/CollidableEntity';\nimport { Color } from '../framework/Color';\nimport { EntityController } from '../framework/EntityController';\nimport { makeFrame } from '../framework/Frame';\nimport { SNAKE_ENTITY_TYPE } from './SnakeEntityController';\nimport { randomNumber } from './util';\n\nexport const POWER_ENTITY_TYPE = 'POWER_ENTITY_TYPE';\nconst POWER_ENTITY_SIZE = 10;\n\nclass PowerEntity extends CollidableEntity {\n  type = POWER_ENTITY_TYPE;\n  bgColor = Color.powerUpColor;\n}\n\nexport class PowersEntityController extends EntityController {\n  shouldAddPower = true;\n}\n\nPowersEntityController.prototype.loadEntity = function () {\n  this.powerEntity = new PowerEntity();\n  this.powerEntity.collisionCallback = (otherEntity) => {\n    this._powerEntityDidCollide(otherEntity);\n  };\n  this.entity.subEntities = [this.powerEntity];\n};\n\nPowersEntityController.prototype.update = function () {\n  if (this.shouldAddPower) {\n    // Update frame of existing power entity\n    this._updatePowerEntityFrame();\n    this.shouldAddPower = false;\n  }\n};\n\nPowersEntityController.prototype._updatePowerEntityFrame = function () {\n  const worldFrame = shared.engine.getWorldFrame();\n  let newFrame;\n  do {\n    newFrame = makeFrame(\n      randomNumber(0, worldFrame.width - POWER_ENTITY_SIZE, POWER_ENTITY_SIZE),\n      randomNumber(0, worldFrame.height - POWER_ENTITY_SIZE, POWER_ENTITY_SIZE),\n      POWER_ENTITY_SIZE,\n      POWER_ENTITY_SIZE\n    );\n  } while (shared.engine.willAnyEntityCollideWith(newFrame));\n\n  this.powerEntity.frame = newFrame;\n  console.info(`[power] added at ${newFrame}`);\n};\n\nPowersEntityController.prototype._powerEntityDidCollide = function (entity) {\n  // If snake ate the power then add power in next update\n  if (entity.type === SNAKE_ENTITY_TYPE) {\n    this.shouldAddPower = true;\n  }\n};\n","import { shared } from '../core/shared';\nimport { Color } from '../framework/Color';\nimport { EntityController } from '../framework/EntityController';\nimport { htmlManager } from './htmlManager';\nimport { PowersEntityController } from './PowersEntityController';\nimport { SnakeEntityController } from './SnakeEntityController';\n\nexport class RootEntityController extends EntityController {}\n\nRootEntityController.prototype.loadEntity = function () {\n  const worldFrame = shared.engine.getWorldFrame();\n  this.entity.frame.width = worldFrame.width;\n  this.entity.frame.height = worldFrame.height;\n  this.entity.bgColor = Color.bgColor;\n\n  this.powerEntityController = new PowersEntityController();\n  this.childEntityControllers.push(this.powerEntityController);\n  this.entity.subEntities.push(this.powerEntityController.entity);\n\n  this.snakeEntityController = new SnakeEntityController();\n  this.childEntityControllers.push(this.snakeEntityController);\n  this.entity.subEntities.push(this.snakeEntityController.entity);\n};\n\nRootEntityController.prototype.didKeyDown = function (key) {\n  // Pass user kbd inputs to snake controller to change direction of snake accordingly\n  this.snakeEntityController.didKeyDown(key);\n};\n\nRootEntityController.prototype.update = function () {\n  if (!shared.engine.paused) {\n    this.snakeEntityController.update();\n    this.powerEntityController.update();\n  }\n\n  htmlManager.update();\n};\n","import { Engine } from './core/Engine';\nimport { Color } from './framework/Color';\nimport { htmlManager } from './snake/htmlManager';\nimport { RootEntityController } from './snake/RootEntityController';\n\nconst FPS = 10;\n\nconst snakeGameEngine = new Engine(RootEntityController, 'game-root', FPS);\n\n// Colors used inside games\nColor.bgColor = '#2b0719';\nColor.snakeColor = '#f7f7f9';\nColor.powerUpColor = '#eacc81';\nColor.fontColor = '#f7f7f9';\n\ndocument.getElementsByTagName('body')[0].style.backgroundColor = Color.bgColor;\n\n// TODO: This should be done after body / DOM is loaded\nsnakeGameEngine.initialize();\n\nhtmlManager.initialize();\n"],"names":["shared","engine","renderingContext","Frame","constructor","x","y","width","height","this","param","isEmpty","prototype","toString","_IN_DEVELOPMENT_canCollideWith","withFrame","extrapolateToPoints","f","thisX1","thisY1","thisX2","thisY2","withX1","withY1","withX2","withY2","isPointInsideThis","makeFrame","makeZeroFrame","detectCollision","aFrame","bFrame","isOriginEqual","isSizeEqual","Engine","RootEntityControllerClass","canvasID","fps","document","getElementById","getContext","_addEventListeners","shouldPause","paused","walkEntityHierarchy","entity","fn","recursiveWalk","currEntity","subEntities","forEach","subEntity","initialize","rootEntityController","didGameOver","fpsInterval","then","Date","now","entityController","recursivelyWalk","currEntityController","childEntityControllers","child","walkEntityControllerHierarchy","ec","loadEntity","draw","pause","console","info","play","reset","window","requestAnimationFrame","loop","gameOver","assert","elapsed","_tick","getWorldFrame","canvasEl","canvas","update","clearRect","_detectCollisionAndForward","addEventListener","event","_didKeyDown","key","didKeyDown","willAnyEntityCollideWith","targetFrame","_collidingEntitiesWithFrame","size","collidingEntities","Set","collidable","frame","add","delete","collidingEntity","didCollideWith","Color","clear","black","white","yellow","red","grey","color","r","g","b","ScoreManager","currentScore","highestScore","incrementCurrentScore","updateHighestScore","resetCurrentScore","Math","max","scoreManager","HTMLManager","gameScoreEl","gameHighScoreEl","gameStatusEl","gameInstructionsEl","startGame","playGame","getElementsByTagName","style","backgroundColor","bgColor","Array","call","getElementsByClassName","el","fontColor","innerHTML","hidden","htmlManager","Entity","type","fillStyle","fillRect","e","otherEntity","error","EntityController","CollidableEntity","collisionCallback","Direction","left","up","right","down","none","mod","randomNumber","min","unit","floor","random","SnakeEntity","snakeColor","super","SnakeEntityController","direction","powerUp","snakeEntities","_createSnakeEntity","snakeHeadEntity","deltaInXYForDirection","worldFrame","dx","dy","newHeadX","newHeadY","newSnakeHeadEntity","push","shift","changeDirectionForKeyCallbacks","w","a","s","d","snakeEntity","_snakeEntityDidCollide","POWER_ENTITY_TYPE","PowerEntity","powerUpColor","PowersEntityController","shouldAddPower","powerEntity","_powerEntityDidCollide","_updatePowerEntityFrame","newFrame","RootEntityController","powerEntityController","snakeEntityController","snakeGameEngine"],"version":3,"file":"index.e5ad638e.js.map"}